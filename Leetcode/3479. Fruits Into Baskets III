# 3479. Fruits Into Baskets III

You are given two arrays of integers, fruits and baskets, each of length n, where fruits[i] represents the quantity of the ith type of fruit, and baskets[j] represents the capacity of the jth basket.

From left to right, place the fruits according to these rules:

Each fruit type must be placed in the leftmost available basket with a capacity greater than or equal to the quantity of that fruit type.
Each basket can hold only one type of fruit.
If a fruit type cannot be placed in any basket, it remains unplaced.
Return the number of fruit types that remain unplaced after all possible allocations are made.

Example 1:
  Input: fruits = [4,2,5], baskets = [3,5,4]
  Output: 1
  Explanation:
    fruits[0] = 4 is placed in baskets[1] = 5.
    fruits[1] = 2 is placed in baskets[0] = 3.
    fruits[2] = 5 cannot be placed in baskets[2] = 4.
    Since one fruit type remains unplaced, we return 1.
Example 2:
  Input: fruits = [3,6,1], baskets = [6,4,7]
  Output: 0
  Explanation:
    fruits[0] = 3 is placed in baskets[0] = 6.
    fruits[1] = 6 cannot be placed in baskets[1] = 4 (insufficient capacity) but can be placed in the next available basket, baskets[2] = 7.
    fruits[2] = 1 is placed in baskets[1] = 4.
    Since all fruits are successfully placed, we return 0.

Constraints:
  n == fruits.length == baskets.length
  1 <= n <= 105
  1 <= fruits[i], baskets[i] <= 109

---

## Solution


---
## Code

```python
class SegmentTree:
    def __init__(self, nums: List[int]):
        self.n = len(nums)
        self.tree = [0] * (self.n * 4)
        self.build(nums, 0, 0, self.n - 1)
    def build(self, nums: List[int], tree_index: int, lo: int, hi: int):
        if lo == hi:
            self.tree[tree_index] = nums[lo]
            return
        mid = (lo + hi) // 2
        self.build(nums, 2 * tree_index + 1, lo, mid)
        self.build(nums, 2 * tree_index + 2, mid + 1, hi)
        self.tree[tree_index] = max(self.tree[2 * tree_index + 1], self.tree[2 * tree_index + 2])
    def update(self, i: int, val: int):
        self._update(0, 0, self.n - 1, i, val)
    def _update(self, tree_index: int, lo: int, hi: int, i: int, val: int):
        if lo == hi:
            self.tree[tree_index] = val
            return
        mid = (lo + hi) // 2
        if i <= mid:
            self._update(2 * tree_index + 1, lo, mid, i, val)
        else:
            self._update(2 * tree_index + 2, mid + 1, hi, i, val)
        self.tree[tree_index] = max(self.tree[2 * tree_index + 1], self.tree[2 * tree_index + 2])
    def query_first(self, target: int) -> int:
        return self._query_first(0, 0, self.n - 1, target)
    def _query_first(self, tree_index: int, lo: int, hi: int, target: int) -> int:
        if self.tree[tree_index] < target:
            return -1
        if lo == hi:
            self.update(lo, -1)
            return lo
        mid = (lo + hi) // 2
        left_child = self.tree[2 * tree_index + 1]
        if left_child >= target:
            return self._query_first(2 * tree_index + 1, lo, mid, target)
        else:
            return self._query_first(2 * tree_index + 2, mid + 1, hi, target)
class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        ans = 0
        tree = SegmentTree(baskets)
        for fruit in fruits:
            if tree.query_first(fruit) == -1:
                ans += 1
        return ans
```

```cpp
class SegmentTree {
 public:
  explicit SegmentTree(const vector<int>& nums) : n(nums.size()), tree(n * 4) {
    build(nums, 0, 0, n - 1);
  }

  void update(int i, int val) {
    update(0, 0, n - 1, i, val);
  }

  int queryFirst(int target) {
    return queryFirst(0, 0, n - 1, target);
  }

 private:
  const int n;
  vector<int> tree;

  void build(const vector<int>& nums, int treeIndex, int lo, int hi) {
    if (lo == hi) {
      tree[treeIndex] = nums[lo];
      return;
    }
    const int mid = (lo + hi) / 2;
    build(nums, 2 * treeIndex + 1, lo, mid);
    build(nums, 2 * treeIndex + 2, mid + 1, hi);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  void update(int treeIndex, int lo, int hi, int i, int val) {
    if (lo == hi) {
      tree[treeIndex] = val;
      return;
    }
    const int mid = (lo + hi) / 2;
    if (i <= mid)
      update(2 * treeIndex + 1, lo, mid, i, val);
    else
      update(2 * treeIndex + 2, mid + 1, hi, i, val);
    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);
  }

  int queryFirst(int treeIndex, int lo, int hi, int target) {
    if (tree[treeIndex] < target)
      return -1;
    if (lo == hi) {
      update(lo, -1);
      return lo;
    }
    const int mid = (lo + hi) / 2;
    const int leftChild = tree[2 * treeIndex + 1];
    return leftChild >= target
               ? queryFirst(2 * treeIndex + 1, lo, mid, target)
               : queryFirst(2 * treeIndex + 2, mid + 1, hi, target);
  }

  int merge(int left, int right) const {
    return max(left, right);
  }
};

class Solution {
 public:
  int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {
    int ans = 0;
    SegmentTree tree(baskets);

    for (const int fruit : fruits)
      if (tree.queryFirst(fruit) == -1)
        ++ans;

    return ans;
  }
};
```
